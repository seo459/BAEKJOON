#include <iostream>
#include <deque>
#include <vector>
#include <queue>
using namespace std;
priority_queue <int> ans_vec;
deque <pair<int, int>> giftList_Q;
int N;
int ans = 0;

void state_record(const bool* selected)
{
	int tmp_ans = 0;
	while (!ans_vec.empty())
		ans_vec.pop(); //clear
	
	for (int i = 0; i < N; i++)
		if (selected[i] == true)
		{
			tmp_ans++;
			ans_vec.push(i);
		}
	if (tmp_ans > ans) ans = tmp_ans; // renew answer
}

bool state_check(const bool* selected)
{
	int* choiced = new int[N] {}; //set '0' all elements
	for (int i = 0; i < N; i++)
	{
		if (selected[i] == true) 
		{
			choiced[giftList_Q[selected[i]].first]++;
			choiced[giftList_Q[selected[i]].second]++;
		}
	}
	for (int i=0; i<N; i++)
	{
		if (selected[i] == true && choiced[i] != 2) //bcs participant must be voted '2'
		{
			delete [] choiced;
			return false;
		}
	}
	delete[] choiced;
	return true;
}

int func(int start_person)
{
	int cur_depth = 0;
	bool* selected = new bool [N] {false};
	deque <pair<int, int>> candidate_Q;
	vector <int> selected_idx;
	selected[start_person] = true;
	selected_idx.push_back(start_person);
	candidate_Q.push_front(make_pair(start_person,cur_depth));
	
	while (!candidate_Q.empty())
	{
		if (candidate_Q.size() <= 0) break; //boundary safety, preventing RUNTIME ERROR
		
		if (selected[candidate_Q.front().first] == false && cur_depth == candidate_Q.front().second) 
		{
			selected[candidate_Q.front().first] = true; // particiated person recording
			selected_idx.push_back(candidate_Q.front().first);
			if (state_check(selected))
			{
				state_record(selected);
			}
			int like_1 = giftList_Q[candidate_Q.front().first].first; //'person have possibility' pushing
			int like_2 = giftList_Q[candidate_Q.front().first].second;
			cur_depth++;
			candidate_Q.pop_front();
			candidate_Q.push_front(make_pair(like_1,++cur_depth));
			candidate_Q.push_front(make_pair(like_2,cur_depth));  //FIFO

		}

		else if (selected[candidate_Q.front().first] == true && cur_depth == candidate_Q.front().second) 
		{
			candidate_Q.pop_front();
		}
		
		else if (selected[candidate_Q.front().first] == true && cur_depth < candidate_Q.front().second) 
		{
			int depth_gap = candidate_Q.front().second - cur_depth;
			for (int i = 0; i < depth_gap + 1; i++)
			{
				selected[selected_idx.back()] = false;
				selected_idx.pop_back();
			}
		} // backing
	}
	delete[] selected;
	return 0;
}

void setting(int& N)
{
	cin >> N;
	for (int i = 0; i < N; i++)
	{
		int a, b;
		cin >> a >> b;
		giftList_Q.push_back(make_pair(a, b));
	}
	return;
}

int main()
{
	setting(N);
	for (int i = 0; i < N; i++)
		func(i);

	return 0;
}
