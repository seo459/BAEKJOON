#include <iostream>
#include <vector>
#include <stack>
//snack move to goal place, He can reaching to goal?
// can't go through Tail region, If snack eat Apple, Tail_region reset.
//-1 : blocking_region , 0 : empty_region , 2 : apple_region , 1 : Tail_region
using namespace std;
int Apple_amout = 0;
vector <pair<int, int>> Tail_vec;
deque <pair<pair<int,int>, pair<int, int>>> Q;

int main()
{
	int N, L;
	char Head_direction;

	int** arr = new int* [N];
	for (int i = 0; i < N; i++)
		arr[i] = new int[N];
	
	int turnning = 0;

}
void consume_node(int** arr, vector <pair<int, int>>& Tail_vec)
{
	int x = Q.front().second.first;
	int y = Q.front().second.second;
	Q.pop_front();
	if (arr[x][y] == 0)
	{
		Tail_vec.push_back(make_pair(x, y));
		arr[x][y] = 1;
	}
	else if (arr[x][y] == 2)
	{
		while (!Tail_vec.empty())
		{
			pair<int, int> tmp = Tail_vec.front();
			arr[Tail_vec.back().first][Tail_vec.back().second] = 0;
			Tail_vec.pop_back();
		}
		Tail_vec.push_back(make_pair(x, y));
	}
}
void pushing_node(int** arr, int time, int turnning, int turned,char Head_direction = 'R')
{
	int x = Q.front().second.first;
	int y = Q.front().second.second;
	if (Head_direction == 'R' && turned < turnning)
	{
		if (arr[x + 1][y] == 0 || 2)
			Q.push_front(make_pair(make_pair(time + 1,turned), make_pair(x + 1, y)));
		if (arr[x][y + 1] == 0 || 2)
			Q.push_front(make_pair(make_pair(time + 1, turned + 1), make_pair(x, y + 1)));
		if (arr[x][y - 1] == 0 || 2)
			Q.push_front(make_pair(make_pair(time + 1, turned + 1), make_pair(x, y - 1)));
	}
	else if (Head_direction == 'R')
	{
		if (arr[x + 1][y] == 0 || 2)
			Q.push_front(make_pair(make_pair(time + 1, turned), make_pair(x + 1, y)));
	}
	else if (Head_direction == 'S' && turned < turnning)
	{
		if (arr[x + 1][y] == 0 || 2)
			Q.push_front(make_pair(make_pair(time + 1, turned + 1), make_pair(x + 1, y)));
		if (arr[x - 1][y] == 0 || 2)
			Q.push_front(make_pair(make_pair(time + 1, turned + 1), make_pair(x - 1, y)));
		if (arr[x][y - 1] == 0 || 2)
			Q.push_front(make_pair(make_pair(time + 1, turned), make_pair(x, y - 1)));
	}
	else if (Head_direction == 'S')
	{
		if (arr[x][y - 1] == 0 || 2)
			Q.push_front(make_pair(make_pair(time + 1, turned), make_pair(x, y - 1)));
	}
	else if (Head_direction == 'L' && turned < turnning)
	{
		if (arr[x -1][y] == 0 || 2)
			Q.push_front(make_pair(make_pair(time + 1, turned), make_pair(x - 1, y)));
		if (arr[x][y + 1] == 0 || 2)
			Q.push_front(make_pair(make_pair(time + 1, turned + 1), make_pair(x, y + 1)));
		if (arr[x][y - 1] == 0 || 2)
			Q.push_front(make_pair(make_pair(time + 1, turned + 1), make_pair(x, y - 1)));
	}
	else if (Head_direction == 'L')
	{
		if (arr[x - 1][y] == 0 || 2)
			Q.push_front(make_pair(make_pair(time + 1, turned), make_pair(x - 1, y)));
	}
	else if (Head_direction == 'N' && turned < turnning)
	{
		if (arr[x + 1][y] == 0 || 2)
			Q.push_front(make_pair(make_pair(time + 1, turned + 1), make_pair(x + 1, y)));
		if (arr[x - 1][y] == 0 || 2)
			Q.push_front(make_pair(make_pair(time + 1, turned + 1), make_pair(x - 1, y)));
		if (arr[x][y + 1] == 0 || 2)
			Q.push_front(make_pair(make_pair(time + 1, turned), make_pair(x, y - 1)));
	}
	else if (Head_direction == 'N')
	{
		if (arr[x][y + 1] == 0 || 2)
			Q.push_front(make_pair(make_pair(time + 1, turned), make_pair(x, y + 1)));
	}
}
